# Glossia - App Plan & Development Guide

## Project Overview

Glossia is a desktop application designed to help users read difficult English texts by breaking them down sentence by sentence, providing word definitions, and generating simplified versions. Built as a pure Rust monorepo with Dioxus for the GUI and OpenRouter integration for AI-powered text processing.

## Core Concept

**Reading Assistance Tool**: Transform complex English texts into digestible, sentence-by-sentence slides with:
- AI-powered sentence simplification via OpenRouter
- Difficult word identification with B2-level meanings
- Proactive content fetching for seamless reading
- Clean, paper-like reading interface
- Pure Rust implementation for maximum performance

## Architecture Philosophy

### Design Principles
- **Separation of Concerns**: Business logic isolated from UI
- **Small Files**: Maximum 100-150 lines per file for readability
- **Clean Dependencies**: Each crate has a single, clear responsibility
- **Proactive Loading**: Pre-fetch next sentence data while reading
- **Seamless Experience**: No waiting for API responses during reading
- **Pure Rust**: No external services or language dependencies

### Monorepo Structure
```
glossia/
├── crates/
│   ├── shared/           # Core types and error handling
│   ├── text-parser/      # Text processing and sentence analysis
│   ├── api-client/       # OpenRouter API integration
│   └── book-reader/      # Reading state and navigation
└── app/                  # Dioxus GUI application
```

## UI/UX Design

### Layout Structure
- **Full Height (100vh)**: Paper-textured background
- **Centered Container**: Main reading area vertically and horizontally aligned
- **Reading Container**: 
  - Original sentence text (top)
  - Simplified version (10px below)
  - Next/Prev navigation controls
- **Floating Elements**:
  - Top: Discrete progress indicator
  - Above reader: Floating section for difficult word meanings
  - Bottom-left: Rounded button showing remaining sentence count
- **Modal**: Medium-style contenteditable div for text input

### Visual Design
```css
/* Paper-like aesthetic */
background: linear-gradient(to bottom, #f9f7f3, #f5f3ef);
box-shadow: 0 2px 4px rgba(0,0,0,0.1);

/* Clean typography */
font-family: Georgia, serif;
line-height: 1.6;

/* Discrete progress bar */
height: 3px;
background: rgba(0,0,0,0.1);
```

## Technical Implementation

### Text Processing Pipeline

#### Frontend (Dioxus)
1. **Text Input**: User pastes text in modal with contenteditable div
2. **Sentence Splitting**: Split by separators: ",.;/|"
3. **Proactive Fetching**: Request simplification for first sentence immediately
4. **Reading Flow**: 
   - Display original text immediately
   - Show loading state for simplified/meanings
   - Pre-fetch next sentence while reading current

#### API Client (Pure Rust)
1. **OpenRouter Integration**: 
   - Direct HTTP requests to OpenRouter API
   - Model: moonshotai/kimi-k2:free
   - Structured JSON prompts for text simplification
2. **Processing Flow**:
   - Build prompt requesting B2-level simplification with word meanings
   - Send request to OpenRouter endpoint
   - Parse JSON response
   - Extract simplified text and word definitions
   - Handle errors and retries

### Data Structures

#### Shared Types (Rust)
```rust
// In shared crate
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimplificationRequest {
    pub sentence: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimplificationResponse {
    pub original: String,
    pub simplified: String,
    pub words: Vec<WordMeaning>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WordMeaning {
    pub word: String,
    pub meaning: String,  // B2-level explanation
}
```

#### Frontend State
```rust
struct ReadingState {
    sentences: VecDeque<String>,        // Sentences to read
    current_sentence: Option<String>,   // Currently displayed
    simplified_cache: HashMap<String, SimplificationResponse>, // Pre-fetched data
    position: usize,                    // Current reading position
    total_sentences: usize,             // Initial count
}
```

### OpenRouter API Integration

#### API Client Implementation (crates/api-client/src/lib.rs)
```rust
use reqwest::Client;
use serde_json::json;
use shared::{SimplificationRequest, SimplificationResponse};

pub struct OpenRouterClient {
    client: Client,
    api_key: String,
    base_url: String,
}

impl OpenRouterClient {
    pub fn new() -> Self {
        Self {
            client: Client::new(),
            api_key: "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".to_string(),
            base_url: "https://openrouter.ai/api/v1".to_string(),
        }
    }
    
    pub async fn simplify(&self, request: SimplificationRequest) -> Result<SimplificationResponse, ApiError> {
        let prompt = self.build_prompt(&request.sentence);
        
        let body = json!({
            "model": "moonshotai/kimi-k2:free",
            "messages": [{
                "role": "user",
                "content": prompt
            }],
            "temperature": 0.3,
            "response_format": { "type": "json_object" }
        });
        
        let response = self.client
            .post(format!("{}/chat/completions", self.base_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .header("Content-Type", "application/json")
            .json(&body)
            .send()
            .await?;
            
        let openrouter_response = response.json::<OpenRouterResponse>().await?;
        let content = openrouter_response.choices[0].message.content.clone();
        
        // Parse the JSON response
        let simplified: SimplificationResponse = serde_json::from_str(&content)?;
        Ok(simplified)
    }
    
    fn build_prompt(&self, sentence: &str) -> String {
        format!(
            r#"Simplify this sentence in modern English without losing detail. 
            Also provide B2-level meanings for difficult words.
            
            Respond ONLY with valid JSON in this exact format:
            {{
                "original": "the original sentence",
                "simplified": "the simplified version",
                "words": [
                    {{"word": "difficult_word", "meaning": "B2-level explanation"}}
                ]
            }}
            
            Sentence to simplify: "{}"
            "#,
            sentence
        )
    }
}
```

## Core Features Implementation

### Reading Flow Management
```rust
impl ReadingState {
    fn next(&mut self) {
        if let Some(sentence) = self.sentences.pop_front() {
            self.current_sentence = Some(sentence);
            self.position += 1;
            
            // Proactively fetch next sentence
            if let Some(next) = self.sentences.front() {
                self.fetch_simplification(next.clone());
            }
        }
    }
    
    fn previous(&mut self) {
        if self.position > 0 {
            if let Some(current) = &self.current_sentence {
                self.sentences.push_front(current.clone());
                self.position -= 1;
                // Load previous sentence from cache
            }
        }
    }
}
```

### Proactive Fetching Strategy
1. **On Text Load**: Immediately request first sentence
2. **While Reading**: When viewing sentence N, fetch N+1
3. **Cache Management**: Store fetched results in HashMap
4. **Error Handling**: Retry mechanism with exponential backoff
5. **Concurrency**: Use tokio for non-blocking API calls

### Claude Integration (Playwright)
```typescript
class ClaudeClient {
  private browser: Browser;
  private cookiesPath = './cookies/claude.json';
  
  async initialize() {
    // Load cookies if exist, otherwise login
    if (fs.existsSync(this.cookiesPath)) {
      await this.context.addCookies(JSON.parse(fs.readFileSync(this.cookiesPath)));
    } else {
      await this.login();
    }
  }
  
  async simplify(sentence: string): Promise<SimplificationResponse> {
    const prompt = `Simplify this sentence in modern English without losing detail. 
    Also provide B2-level meanings for difficult words.
    Respond in JSON format with fields: simplified, words (array of {word, meaning}).
    
    Sentence: "${sentence}"`;
    
    // Send prompt and wait for response
    const response = await this.sendPrompt(prompt);
    
    // Validate with Zod
    return SimplificationResponse.parse(response);
  }
  
  private async waitForResponse() {
    // Monitor network for /latest route
    await this.page.waitForResponse(response => 
      response.url().includes('/latest')
    );
    
    // Extract answer
    const messageDiv = await this.page.$('.font-claude-message');
    return await messageDiv?.textContent();
  }
}
```

## Component Architecture (Dioxus)

### Main App Component
```rust
#[component]
fn App() -> Element {
    let mut reading_state = use_signal(|| ReadingState::default());
    let mut show_input_modal = use_signal(|| false);
    
    rsx! {
        div {
            class: "app-container",
            style: "height: 100vh; background: linear-gradient(to bottom, #f9f7f3, #f5f3ef);",
            
            ProgressBar { 
                current: reading_state().position,
                total: reading_state().total_sentences 
            }
            
            div {
                class: "centered-container",
                
                if reading_state().simplified_cache.contains_key(&reading_state().current_sentence.clone().unwrap_or_default()) {
                    WordMeanings { 
                        words: reading_state().get_current_words() 
                    }
                }
                
                ReadingContainer {
                    original: reading_state().current_sentence.clone(),
                    simplified: reading_state().get_current_simplified(),
                    on_next: move |_| reading_state.write().next(),
                    on_prev: move |_| reading_state.write().previous()
                }
            }
            
            FloatingButton {
                count: reading_state().sentences.len(),
                onclick: move |_| show_input_modal.set(true)
            }
            
            if show_input_modal() {
                TextInputModal {
                    onsubmit: move |text| {
                        reading_state.write().load_text(text);
                        show_input_modal.set(false);
                    }
                }
            }
        }
    }
}
```

### Reading Container Component
```rust
#[component]
fn ReadingContainer(
    original: Option<String>,
    simplified: Option<String>,
    on_next: EventHandler<()>,
    on_prev: EventHandler<()>
) -> Element {
    rsx! {
        div {
            class: "reading-container",
            
            div {
                class: "original-text",
                {original.as_deref().unwrap_or("No text loaded")}
            }
            
            div {
                class: "simplified-text",
                style: "margin-top: 10px;",
                
                if let Some(text) = simplified {
                    {text}
                } else {
                    div {
                        class: "loading-indicator",
                        "Loading simplified version..."
                    }
                }
            }
            
            div {
                class: "navigation-controls",
                button {
                    onclick: move |_| on_prev.call(()),
                    "Previous"
                }
                button {
                    onclick: move |_| on_next.call(()),
                    "Next"
                }
            }
        }
    }
}
```

### Text Input Modal Component
```rust
#[component]
fn TextInputModal(onsubmit: EventHandler<String>) -> Element {
    let mut text_content = use_signal(String::new);
    
    rsx! {
        div {
            class: "modal-overlay",
            
            div {
                class: "modal-content",
                
                div {
                    contenteditable: "true",
                    class: "text-input",
                    style: "min-height: 200px; padding: 20px; border: 1px solid #ddd;",
                    oninput: move |e| text_content.set(e.value.clone()),
                    "Paste your text here..."
                }
                
                button {
                    onclick: move |_| onsubmit.call(text_content()),
                    "Start Reading"
                }
            }
        }
    }
}
```

## Development Workflow

### Setup Commands
```bash
# Build the workspace
cargo build

# Run in development mode
cargo run --bin glossia

# Run with hot-reload
dx serve --platform desktop

# Build for production
cargo build --release

# Run tests
cargo test
```

### Configuration
```rust
// In api-client/src/config.rs
pub const OPENROUTER_API_KEY: &str = "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";
pub const OPENROUTER_BASE_URL: &str = "https://openrouter.ai/api/v1";
pub const MODEL: &str = "moonshotai/kimi-k2:free";
pub const MAX_RETRIES: u32 = 3;
```

## Performance Optimizations

### Caching Strategy
- **In-Memory Cache**: HashMap for simplified sentences
- **Proactive Loading**: Always fetch N+1 while reading N
- **Request Deduplication**: Prevent duplicate API calls
- **Local Cookie Storage**: Avoid repeated Claude logins

### Error Handling
- **Retry Logic**: 3 attempts with exponential backoff
- **Fallback Display**: Show original text if simplification fails
- **Graceful Degradation**: Continue reading even if API is down
- **Response Validation**: Ensure JSON structure matches expectations
- **Rate Limiting**: Handle OpenRouter rate limits gracefully

## Dependencies

### Workspace Dependencies
```toml
[workspace]
members = ["app", "crates/*"]

[workspace.dependencies]
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
reqwest = { version = "0.11", features = ["json"] }

# App-specific dependencies
[dependencies]
dioxus = { version = "0.6", features = ["desktop", "router"] }
dioxus-desktop = { version = "0.6", features = ["transparent"] }

# API client dependencies
[dependencies.reqwest]
version = "0.11"
features = ["json", "rustls-tls"]

[dev-dependencies]
dioxus-hot-reload = "0.6"
```

## Success Metrics

### MVP Goals
- [ ] Text input and sentence splitting works correctly
- [ ] OpenRouter integration successfully simplifies sentences
- [ ] Proactive fetching eliminates wait times
- [ ] Navigation updates sentence counter properly
- [ ] Progress bar accurately reflects reading position
- [ ] Pure Rust implementation with no external services

### User Experience Goals
- [ ] Instant display of original text
- [ ] Smooth transitions between sentences
- [ ] Clear B2-level word explanations
- [ ] Responsive paper-like interface
- [ ] Seamless reading flow without interruptions
- [ ] Fast and reliable API responses
